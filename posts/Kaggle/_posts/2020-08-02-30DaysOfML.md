---
layout: post
title: 30 Days of ML Challenge
subtitle: Challenge Overview
cover-img: /assets/img/Kaggle/Kaggle-2x1.png
thumbnail-img: /assets/img/Kaggle/Kaggle.png
share-img: /assets/img/Kaggle/Kaggle-2x1.png
readtime: true
tags: [Kaggle]
---

![30DaysOfML](../../../assets/img/Kaggle/30DaysOfML.png)

# Overview

I joined [this 30-day challenge](https://www.kaggle.com/thirty-days-of-ml) to have a nice daily refresher of basic ML concepts,
and to finally join the Kaggle community. Looking forward to sharing 
my experience.

| Course      | Certificate |
| ----------- | ----------- |
| [Python](https://www.kaggle.com/learn/python)         | ![Python_Course](../../../assets/img/Kaggle/Certificates/Python_Course.png)        |
| [Intro to ML](https://www.kaggle.com/learn/intro-to-machine-learning)         |    |
| [Intermediate ML](https://www.kaggle.com/learn/intermediate-machine-learning)         |   |



# Python


## Day 1 - 08/02/2021: Level up to Contributor

Today's challenge was very simple. It consisted of using a dummy 
notebook and adding some code snippets to build a simple Random Forest
classifier model to predict whether an individual would survive the titanic
based on simple features. This is the quintessential Kaggle example
that everyone refers to. Interestingly enough, women
survived at a rate of 74%, whereas men only survived at a rate of 19%. 
It does beg the question, why the disparity? 

As part of the daily challenge, I submitted the predictions from the Random
Forest classifier, posted a comment, and gave an upvote to another 
individual's post. The objective was to raise my ranking from Novice 
to Contributor status. Overall, the initial challenge was pretty easy.

![Titantic_Prediction](../../../assets/img/Kaggle/Day1/Titantic_Prediction.png)

## Day 2 - 08/03/2021: Hello, Python

Today's challenge was very easy. 
It was basic arithmetic operators and order of operations in python.
I like the simplicity of it. 
I could see being able to understand it easily even if I was not fluent in python.
It was nice how it covered little tricks like the in-place swapping `b, a = a, b`.

## Day 3 - 08/04/2021: Functions and Getting Help

Another simple challenge. The idea of this
exercise was to learn the anatomy of a function and
how to use `help()` to learn more. 

I did learn that  `round()` can round to a negative number of decimal places (i.e. integer place).
What that means essentially is for each value that is negative we round to the `10*n`th place.
So if the value is `-1`, we round to the tens place. If it is -3, we round to the thousands place.

```python
# Will yield 0 because 10 rounded to the hundreds is 0.
round(10, -2)
```

## Day 4 - 08/05/2021: Booleans and Conditionals 

This challenge got a little more interesting. 
They structured the examples for conditional evaluation as word problems and
ask you to identify the errors based on the scenario you are trying to solve.
For example there are a set of 4 conditionals associated with if you should take an umbrella,
but given the order of operations and lack of parentheses it evaluates incorrectly.

The concepts that were introduced were simple. There was a few examples where I solved things in a different fashion:

```python
def sign(num):
    """
    This function returns 1 if positive, -1 if negative and 0 if 0
    """
    if num == 0:
        return num
    return num / abs(num)
```

vs. the solution:

```python
def sign(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    else:
        return 0
```

...and an interesting blackjack simulator to determine if you as a player should hit. The objective is to beat the dealer in 50000 simulated games.
I chose to experimentally derive rules instead of research well-formed strategy online. I marginally improved over the basic strategy of never hitting.
Surprisingly you can win ~38% of your games if you never hit. My simplistic strategy improves upon it by a little over 3.5%.

![Blackjack](../../../assets/img/Kaggle/Day4/Blackjack.png)

I think given more time I would explore more strategies to improve probabilities given the number of aces.
Interestingly you don't get to have any knowledge of the dealer's showing cards to inform your strategy.

Overall this was an enjoyable lesson.

## Day 5 - 08/06/2021: 

### Lists and Tuples

I have begun to really enjoy their liberal use of the help function 
while explaining simple concepts.  I think in some ways this really 
cuts the corner on googling for docs and trying to make sure you are 
seeing the right version. That said using an IDE to drill into the respective 
function is usually my goto. I tend to use PyCharm's Community edition since
it is free and super easy to customize. 
I actually use it to work on this website!
That said, I could see being in a situation where not having a GUI at your
disposal is your day-to-day work, and for that it would be indispensable.

An interesting learning for me was that I learned about the `bit_length()` 
function. I could see this as being useful it you are trying to profile
your memory footprint programmatically, at various points throughout 
execution of a program:

```python
Help on built-in function bit_length:

bit_length() method of builtins.int instance
    Number of bits necessary to represent self in binary.
    
    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
```

The exercise was actually simpler than the previous day, but it 
presented an interesting question which distilled into its simplest parts is:

> Given a list, determine if your element is in the second half, 
> but is not the final element.

In the example they pose a list of party members in a 
sorted list by arrival time. You need to find out if the guest in question
arrived fashionably late. There are many ways to slice this problem. My
solution looked like this:

```python
def fashionably_late(arrivals, name):
    """Given an ordered list of arrivals to the party and a name, return whether the guest with that
    name was fashionably late.
    """
    name_index = arrivals.index(name)
    return name_index != len(arrivals) -1 and name_index >= (len(arrivals) / 2)
```

### Loops and List Comprehensions

This section was a little interesting. 
I liked the comprehensive nature by which they explained one of the examples.

I like how they consider efficiency. 
For instance, my solution required a pointer whereas theirs used the index 
plus `range()` to keep track of the previous element. I would argue
they are both pretty readable, but in terms of conciseness I prefer their
solution.

My Solution:

```python
def menu_is_boring(meals):
    """Given a list of meals served over some period of time, return True if the
    same meal has ever been served two days in a row, and False otherwise.
    """
    prev_meal = None
    for meal in meals:
        if meal == prev_meal:
            return True
        prev_meal = meal
    return False
```

Their Solution:

```python
def menu_is_boring(meals):
    # Iterate over all indices of the list, except the last one
    for i in range(len(meals)-1):
        if meals[i] == meals[i+1]:
            return True
    return False
```

## Day 6 - 08/07/2021: Strings and Dictionaries

This lesson taught me about dictionary comprehensions. Very cool.
I wish I had know about this before. It actually allowed me to 
do a simple, yet readable one liner solution:

My solution:
```python
def multi_word_search(doc_list, keywords):
    """
    Takes list of documents (each document is a string) and a list of keywords.  
    Returns a dictionary where each key is a keyword, and the value is a list of indices
    (from doc_list) of the documents containing that keyword

    >>> doc_list = ["The Learn Python Challenge Casino.", "They bought a car and a casino", "Casinoville"]
    >>> keywords = ['casino', 'they']
    >>> multi_word_search(doc_list, keywords)
    {'casino': [0, 1], 'they': [1]}
    """
    return {keyword:word_search(doc_list, keyword) for keyword in keywords}
```

Their solution: 
```python
def multi_word_search(documents, keywords):
    keyword_to_indices = {}
    for keyword in keywords:
        keyword_to_indices[keyword] = word_search(documents, keyword)
    return keyword_to_indices
```

Both solutions leverage the function codified in the previous example for this 
day's lesson:
```python
def word_search(doc_list, keyword):
    """
    Takes a list of documents (each document is a string) and a keyword. 
    Returns list of the index values into the original list for all documents 
    containing the keyword.

    Example:
    doc_list = ["The Learn Python Challenge Casino.", "They bought a car", "Casinoville"]
    >>> word_search(doc_list, 'casino')
    >>> [0]
    """
    indices = []
    for i in range(len(doc_list)):
        tokenized_prepped_doc = doc_list[i].lower().translate(doc_list[i].maketrans('', '', ',.')).split()
        if keyword.lower() in tokenized_prepped_doc:
            indices.append(i)
        
    return indices 
```

In this case I actually prefer my solution over the one proposed by the 
course instructor. There is no sacrifice in terms of readability and it
also helps to serve as a reminder that dictionary comprehensions are a powerful
tool to short circuit verbose looping.

## Day 7 - 08/08/2021: Working with External Libraries

Today I was reminded of how useful the `dir()` function is and how useful it
is as a companion function to `help()`. 
I am realizing there is a lot of efficiencies that can be gained by 
re-observing the basics from the lens of a python beginner.

```python
>>> print(dir(math))

['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'remainder', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']
```

The challenges from the exercise were interesting. 
A little challenging, but not too difficult.
The most memorable one was coding a function to determine if the players hand
beats an opponent's hand in blackjack. It was pretty straightforward. Here is 
my solution:

```python
def blackjack_hand_greater_than(hand_1, hand_2):
    """
    Return True if hand_1 beats hand_2, and False otherwise.
    
    In order for hand_1 to beat hand_2 the following must be true:
    - The total of hand_1 must not exceed 21
    - The total of hand_1 must exceed the total of hand_2 OR hand_2's total must exceed 21
    
    Hands are represented as a list of cards. Each card is represented by a string.
    
    When adding up a hand's total, cards with numbers count for that many points. Face
    cards ('J', 'Q', and 'K') are worth 10 points. 'A' can count for 1 or 11.
    
    When determining a hand's total, you should try to count aces in the way that 
    maximizes the hand's total without going over 21. e.g. the total of ['A', 'A', '9'] is 21,
    the total of ['A', 'A', '9', '3'] is 14.
    
    Examples:
    >>> blackjack_hand_greater_than(['K'], ['3', '4'])
    True
    >>> blackjack_hand_greater_than(['K'], ['10'])
    False
    >>> blackjack_hand_greater_than(['K', 'K', '2'], ['3'])
    False
    """
    BLACKJACK = 21
    FACECARDS = 'JQK'
    
    def determine_hand_value(hand):
        """
        Helper function to determine value of hand.
        """
        val = 0
        aces = 0
        for card in hand:
            if card in FACECARDS:
                val += 10
            elif card != 'A':
                val += int(card)
            else:
                aces += 1
                
        # determine if having an ace with value of 11 is valid or not.
        if aces > 0:
            eleven_and_ones = val + 11 + (aces -1) * 1
            if eleven_and_ones <= BLACKJACK:
                val = eleven_and_ones
            else:
                val += aces
        return val
                
                      
    hand1_val = determine_hand_value(hand_1)
    hand2_val = determine_hand_value(hand_2)
    
    # If player has a valid hand and the opponent either busted or has a lower value then the player wins
    if hand1_val <= BLACKJACK and  (hand2_val > BLACKJACK or hand2_val < hand1_val):
        return True
    
    # Player loses
    return False
```

After completing this lesson I earned a 
certificate of completion for the Python course.

# Intro to ML

## Day 8 - 08/09/2021: 

### How Models Work

This section was pretty elementary, but I felt like
the information was conveyed was intentional and thought-provoking.
Starting with decision trees makes a lot of sense given
the human thought process in generating a simple mental
model.

### Basic Data Exploration

Introducing the `describe()` function is a nice touch.
I haven't really seen it used much in the wild, and I 
see it as being a simple EDA first step. 

The exercise was pretty simple. But it had a few nice
examples of how to dissect a simple dataframe to answer
simple questions about housing prices:

```python
home_data_describe_df = home_data.describe()
# What is the average lot size (rounded to nearest integer)?
avg_lot_size = int(round(home_data_describe_df['LotArea']['mean'], 0))
# As of today, how old is the newest home (current year - the date in which it was built)
newest_home_age = 2021 - int(round(home_data_describe_df['YearBuilt']['max'], 0))
```